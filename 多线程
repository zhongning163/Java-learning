/*
进程：正在进行中的程序

线程：进程中一个负责程序执行的控制单元（执行路径）
一个进程中可以多执行路径，称之为多线程

一个进程中至少要有一个线程

开启多个线程是为了同时运行多部分代码

每一个线程都有自己运行的内容，这个内容可以成为线程要执行的任务

多线程好处：解决了多部分同时运行的问题

多线程弊端：线程太多导致效率降低

JVM中执行main函数的线程与负责垃圾回收的线程就是多线程

Object类中的finalize方法会在垃圾回收器运行时执行，System类中的gc方法会提醒垃圾回收器运行，但不确定什么时候运行
*/
class Demo extends Object
{
	public void finalize()
	{
		System.out.println("垃圾回收中");
	}
}

class  ThreadDemo
{
	public static void main(String[] args) 
	{
		new Demo();
		new Demo();
		System.gc();
		new Demo();
		System.out.println("Hello World!");
	}
}

/********************************************************************************************/

/*
创建新执行线程有两种方法：
一种是将类声明为Thread的子类，该子类应重写Thread类的run方法
步骤：
1.定义一个类继承Thread类。
2.覆盖Thread类中的run方法
3.直接创建Thread的子类对象创建线程
4.调用start方法开启线程并调用线程的任务run方法执行

创建线程的目的是为了开启一条执行路径，去运行指定的代码和其他代码实现同时运行

而运行的指定代码就是这个执行路径的任务

JVM创建的主线程的任务都定义在了主函数中

Thread类用于描述线程，线程是需要任务的。所以Thread类也对任务进行描述
这个任务就通过Thread类中的run方法实现，也就是说，run方法就是封装自定义线程运行任务的函数

开启线程是为了运行指定代码，所以只有继承Thread类，并覆写run方法
将运行的代码定义在run方法中即可
*/
class Demo extends Thread
{
	private String name;
	Demo(String name)
	{
		//super(name);		//将name作为线程的名称，因为Thread类中有Thread（String name）构造方法
		this.name=name;
	}
	public void run()
	{
		for(int x=0;x<10;x++)
		{
			for(int y=-9999999;y<99999999;y++)
			{
				for(int z=-999999;z<9999999;z++)
				{}
			}
			System.out.println(name+"...x="+x+"..."+Thread.currentThread().getName());	//可以通过Thread的getName方法获取线程名称  Thread-编号（从0开始）
													//Thread类中的currentThread方法可以返回当前正在运行的线程对象，这个方法是static的，可以通过类名直接调用
		}
	}
}
class ThreadDemo2 
{
	public static void main(String[] args) 
	{
		Demo d1=new Demo("旺财");
		Demo d2=new Demo("xiaoqiang");
		d1.start();		//如果直接写d1.run(),只是调用一个普通的run方法，并没有开启一个新的线程
		System.out.println("Hello World!..."+Thread.currentThread().getName());			//这个程序有三个线程，主线程、以及创建的两个线程。主线程的名字就是main
		d2.start();
	}
}
