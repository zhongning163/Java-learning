/*
Object obj =new Object();
void show()
{
	synchronized(obj)  // 同步代码块，对于锁的操作是隐式的
	{
		code...;
	}
}

//JDK1.5之后将同步和锁封装成了对象，并将操作锁的隐式方式定义到了该对象中
//将隐式动作变成了显式动作
Lock lock=new ReentrantLock();  
void show()
{
	lock.lock();//获取锁
	code... throws Exception（）
	lock.unlock();//释放锁 释放锁放在finally中
}
*/

import java.util.concurrent.locks.*;

class Resource
{
	private String name;
	private int count=1;
	private boolean flag=false;

	Lock lock=new ReentrantLock();
	public void set(String name)
	{
		lock.lock();
		try
		{
			while(flag)
			try{this.wait();}catch(InterruptedException e){}
			this.name=name+count;
			count++;
			System.out.println(Thread.currentThread().getName()+"....生产者...."+this.name);
			flag=true;
			//用notifyAll而不是notify的原因：用notify只唤醒一个被冻结的线程，如果唤醒的是本方而不是对方的线程，
			//四个线程都进入冻结状态，这时会出现死锁现象
			//因此用notifyAll保证对方被唤醒，避免出现死锁现象
			notifyAll();
		}
		finally
		{
			lock.unlock();
		}
	}

	public void out()
	{
		lock.lock();
		try
		{
			while(!flag)
			try{this.wait();}catch(InterruptedException e){}
			System.out.println(Thread.currentThread().getName()+"....消费者.........."+this.name);
			flag=false;
			notifyAll();
		}
		finally
		{
			lock.unlock();
		}
	}
}

class Producer implements Runnable
{
	 private Resource r;
	 Producer(Resource r)
	 {
		 this.r=r;
	 }
	 
	 public void run()
	 {
		while(true)
		{
			r.set("烤鸭");
		}
	 }
}


class Consumer implements Runnable
{
	 private Resource r;
	 Consumer(Resource r)
	 {
		 this.r=r;
	 }
	 
	 public void run()
	 {
		while(true)
		{
			r.out();
		}
	 }
}
class LockDemo
{
	public static void main(String[] args) 
	{
		Resource r=new Resource();

		Producer p=new Producer(r);
		Consumer c=new Consumer(r);

		Thread t0=new Thread(p);
		Thread t1=new Thread(p);
		Thread t2=new Thread(c);
		Thread t3=new Thread(c);

		t0.start();
		t1.start();
		t2.start();
		t3.start();
	}
}
